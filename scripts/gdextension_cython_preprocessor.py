import argparse
import textwrap
from pathlib import Path
import re
from typing import Optional, List, Dict
from dataclasses import dataclass


PRAGMA_RE = re.compile(r"^(?P<indentation>\s*)# godot_extension:\s+(?P<pragma>.*)$")
CLASS_RE = re.compile(r"^cdef class (?P<class_name>\w+)")
METHOD_RE = re.compile(
    r"^cdef\s+(inline\s+)?(?P<return_type>\w+\s*\*?)\s+(?P<method_name>\w+)\((?P<param>.*)\):"
)

INJECT_CODE_PRAGMA = "generate_code()"
AUTOGENERATED_HEADER = "*** Start of auto-generated code ***"
AUTOGENERATED_FOOTER = "*** End of auto-generated code ***"


@dataclass
class MethodDef:
    method_name: str
    is_staticmethod: bool
    is_const: bool
    is_virtual: bool
    return_type: str
    parameters: Dict[str, str]


@dataclass
class ClassDef:
    class_def_at_line: int
    class_name: str
    parent_class_name: str
    methods: List[MethodDef]
    inject_code_at_line: int


def generate_injected_code_method(spec: MethodDef, class_spec: ClassDef, virtual_flavor: bool = False) -> str:
    code = f"""
@staticmethod
cdef void __godot_extension_class_{'virtual_' if virtual_flavor else ''}meth_{spec.method_name}(
    {'void *method_userdata,' if not virtual_flavor else ''}
    GDExtensionClassInstancePtr p_instance,
    const GDExtensionConstTypePtr *p_args,
    GDExtensionTypePtr r_ret,
) noexcept with gil:
"""

    if spec.return_type == "void":
        code += "    "
    else:
        code += f"    (<{spec.return_type}*>r_ret)[0] = "
    if spec.is_staticmethod:
        code += f"{class_spec.class_name}.{spec.method_name}(\n"
    else:
        code += f"(<{class_spec.class_name}>p_instance).{spec.method_name}(\n"

    for i, (_, param_type) in enumerate(spec.parameters.items()):
        code += f"        (<{param_type}*>p_args[{i}])[0],\n"
    code += "    )\n"

    if spec.is_virtual and not virtual_flavor:
        code += "\n"
        code += generate_injected_code_method(spec, class_spec, virtual_flavor=True)

    return code


def generate_injected_code_register(spec: ClassDef) -> str:
    code = f"""
@staticmethod
def __godot_extension_unregister_class():
    unregister_extension_class(b"{spec.class_name}")

@staticmethod
cdef GDExtensionClassInstancePtr __godot_extension_create_instance(void* p_userdata) noexcept with gil:
    cdef {spec.class_name} obj = {spec.class_name}()
    Py_INCREF(obj)
    return <PyObject*>obj

@staticmethod
cdef void __godot_extension_free_instance(void* p_userdata, GDExtensionClassInstancePtr p_instance) noexcept with gil:
    Py_DECREF(<{spec.class_name}>p_instance)

@staticmethod
def __godot_extension_register_class():
    register_extension_class_creation(
        b"{spec.class_name}",
        b"{spec.parent_class_name}",
        &{spec.class_name}.__godot_extension_create_instance,
        &{spec.class_name}.__godot_extension_free_instance,
        &{spec.class_name}.__godot_extension_get_virtual,
    )
"""
    for method in spec.methods:
        cooked_params = "["
        for param_name, param_type in method.parameters.items():
            cooked_params += "("
            cooked_params += f'b"{param_name}", b"{param_type}"'
            cooked_params += "), "
        cooked_params += "]"

        code += textwrap.indent(
            f"""
register_extension_class_method(
    b"{spec.class_name}",
    b"{method.method_name}",
    &{spec.class_name}.__godot_extension_class_meth_{method.method_name},
    {'True' if method.is_staticmethod else 'False'},
    b"{method.return_type}",
    {cooked_params}
)
""",
            prefix="    ",
        )

    # TODO: cache virtual methods name to avoid pystr to gd_string_name_t conversions
    code += """
@staticmethod
cdef GDExtensionClassCallVirtual __godot_extension_get_virtual(void *p_class_userdata, GDExtensionConstStringNamePtr p_name) noexcept with gil:
    cdef gd_string_t gd_candidate_name
"""

    for method in spec.methods:
        if not method.is_virtual:
            continue
        code += f"""
    gd_candidate_name = gd_string_from_pybytes(b"{method.method_name}")
    if gd_string_name_op_equal_string(<const gd_string_name_t *>p_name, &gd_candidate_name):
        gd_string_del(&gd_candidate_name)
        return &{spec.class_name}.__godot_extension_class_virtual_meth_{method.method_name}
    gd_string_del(&gd_candidate_name)
"""

    code += """
    return NULL
"""

    return code


def generate_injected_code(spec: ClassDef) -> str:
    code = ""

    for method_spec in spec.methods:
        method_code = generate_injected_code_method(method_spec, spec)
        code += textwrap.indent(method_code, prefix="    ")

    register_code = generate_injected_code_register(spec)
    code += textwrap.indent(register_code, prefix="    ")

    return code


def handle_pointer_type(raw_type: str) -> str:
    # Type is not a real Godot object, but we still use `gd_object_t`
    # to represent the fact it is a pointer
    # if raw_type.endswith("*"):
    #     return "gd_object_t"
    try:
        pointed_type, _ = raw_type.split()
        return f"{pointed_type}*"
    except ValueError:
        return raw_type.strip()


def extract_classes_from_code(code_lines: List[str]) -> List[ClassDef]:
    code_lines = enumerate(code_lines)
    classes: List[ClassDef] = []

    current_class: Optional[ClassDef] = None
    for i, line in code_lines:
        match = PRAGMA_RE.match(line)
        if not match:
            continue

        pragma = match.group("pragma").strip()
        if pragma == INJECT_CODE_PRAGMA:
            if current_class is None:
                raise RuntimeError(
                    f"Line {i + 1}: `# godot_extension: {pragma}` must be within a `# godot_extension: class(...)` pragma"
                )

            if current_class.inject_code_at_line != -1:
                raise RuntimeError(
                    f"Line {i + 1}: `# godot_extension: {pragma}` already defined at line {current_class.inject_code_site} for class `{current_class.class_name}`"
                )

            current_class.inject_code_at_line = i

        elif pragma in (AUTOGENERATED_HEADER, AUTOGENERATED_FOOTER):
            continue

        else:

            def _method(const: bool = False, virtual: bool = False) -> MethodDef:
                if current_class is None:
                    raise RuntimeError(
                        f"`# godot_extension: method(...)` must be within a `# godot_extension: class(...)` pragma"
                    )

                if not isinstance(const, bool):
                    raise RuntimeError("`const` parameter must be a boolean")
                is_const = const

                if not isinstance(virtual, bool):
                    raise RuntimeError("`virtual` parameter must be a boolean")
                is_virtual = virtual

                try:
                    _, line = next(code_lines)
                    is_staticmethod = line.strip() == "@staticmethod"
                    if is_staticmethod:
                        _, line = next(code_lines)
                except StopIteration:
                    raise RuntimeError("unexpected end of file")

                if line.strip().startswith("@"):
                    raise RuntimeError("Only `@staticmethod` decorator is supported")

                # Retrieve the parameters that can span accross multiple lines
                try:
                    current_line = iter(line[line.index("(") + 1 :])
                    meth_signature = line[: line.index("(") + 1].strip()
                except ValueError:
                    raise RuntimeError(
                        f"expected method signature `cdef [inline] gd_xxx_t foo({'' if is_staticmethod else 'self, '}gd_yyy_t bar, ...)"
                    )
                open_parenthesises = 1
                while open_parenthesises > 0:
                    for c in current_line:
                        if c == "(":
                            open_parenthesises += 1
                        elif c == ")":
                            open_parenthesises -= 1
                        meth_signature += c
                    if open_parenthesises:
                        try:
                            _, current_line = iter(next(code_lines))
                        except StopIteration:
                            raise RuntimeError("unexpected end of file")

                match = METHOD_RE.match(meth_signature)
                if not match:
                    raise RuntimeError(
                        f"expected method signature `cdef [inline] gd_xxx_t foo({'' if is_staticmethod else 'self, '}gd_yyy_t bar, ...)"
                    )

                params = {}
                for i, raw_param in enumerate(match.group("param").split(",")):
                    if i == 0 and not is_staticmethod:
                        if raw_param != "self":
                            raise RuntimeError(
                                "expected first paramater for non static method to be `self`"
                            )
                        continue

                    try:
                        param_type, param_name = raw_param.split()
                    except ValueError:
                        raise RuntimeError(f"bad parameter {raw_param!r}")
                    params[param_name] = handle_pointer_type(param_type)

                current_class.methods.append(
                    MethodDef(
                        method_name=match.group("method_name"),
                        is_staticmethod=is_staticmethod,
                        is_const=is_const,
                        is_virtual=is_virtual,
                        return_type=handle_pointer_type(match.group("return_type")),
                        parameters=params,
                    )
                )

            def _class(parent: str) -> ClassDef:
                nonlocal current_class
                nonlocal classes

                if not isinstance(parent, str):
                    raise RuntimeError("`parent` parameter must be a string")

                try:
                    class_def_at_line, line1 = next(code_lines)
                    _, line2 = next(code_lines)

                    match = CLASS_RE.match(line2)
                    if line1.strip() != "@cython.final" or not match:
                        raise RuntimeError("expected `@cython.final` decorated cdef class")

                except StopIteration:
                    raise RuntimeError("unexpected end of file")

                current_class = ClassDef(
                    class_def_at_line=class_def_at_line,
                    class_name=match.group("class_name"),
                    parent_class_name=parent,
                    methods=[],
                    inject_code_at_line=-1,
                )
                classes.append(current_class)

            try:
                eval("_" + pragma, {"_method": _method, "_class": _class})
            except NameError as exc:
                raise RuntimeError(f"Line {i + 1}: Unknown pragma `{line.strip()}`") from exc
            except Exception as exc:
                raise RuntimeError(
                    f"Line {i + 1}: Invalid pragma `{line.strip()}` ({exc})"
                ) from exc

    return classes


def parse_code(code: str) -> str:
    # First pass: remove old autogenerate code if any
    iter_lines = enumerate(code.splitlines())
    code_lines = []
    currently_in_autogenerated_code = False
    for i, line in iter_lines:
        match = PRAGMA_RE.match(line)
        if match:
            pragma = match.group("pragma").strip()
            if pragma == AUTOGENERATED_HEADER:
                if currently_in_autogenerated_code:
                    raise RuntimeError(f"Line {i + 1}: Nested autogenerated header are not allowed")
                currently_in_autogenerated_code = True
                continue
            elif pragma == AUTOGENERATED_FOOTER:
                if not currently_in_autogenerated_code:
                    raise RuntimeError(
                        f"Line {i + 1}: Found autogenerated footer without matching header"
                    )
                currently_in_autogenerated_code = False
                continue

        if not currently_in_autogenerated_code:
            code_lines.append(line)

    # Second pass: find `# godot_extension: ...` pragma instructions
    classes = extract_classes_from_code(code_lines)

    # Last pass: inject generated code in the `# godot_extension: inject_code_site` pragmas
    for klass in reversed(classes):
        if klass.inject_code_at_line == -1:
            raise RuntimeError(
                f"Line {klass.class_def_at_line}: Missing pragam `# godot_extension: inject_code_site` for class `{klass.class_name}`"
            )
        code_lines = (
            code_lines[: klass.inject_code_at_line + 1]
            + [
                f"    # godot_extension: {AUTOGENERATED_HEADER}",
                generate_injected_code(klass),
                f"    # godot_extension: {AUTOGENERATED_FOOTER}",
            ]
            + code_lines[klass.inject_code_at_line + 1 :]
        )

    code = "\n".join(code_lines)
    if not code.endswith("\n"):
        code += "\n"
    return code


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Generate Godot extension class boilerplate for Cython code"
    )
    parser.add_argument(
        "input",
        type=Path,
    )
    parser.add_argument(
        "--output",
        "-o",
        type=Path,
    )
    parser.add_argument(
        "--debug",
        action="store_true",
    )
    args = parser.parse_args()
    if args.input.suffix not in (".pyx", ".pxi"):
        raise SystemExit("Expected .pyx/.pxi file as input")

    input_code = args.input.read_text(encoding="utf8")
    try:
        output_code = parse_code(input_code)
    except RuntimeError as exc:
        if args.debug:
            raise
        else:
            raise SystemExit(str(exc)) from exc
    if args.output:
        args.output.write_text(output_code, encoding="utf8")
    else:
        args.input.write_text(output_code, encoding="utf8")
