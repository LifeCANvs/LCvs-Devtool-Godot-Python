{% from 'builtins_pyx/constructor.pyx.j2' import render_constructors with context %}
{% from 'builtins_pyx/member.pyx.j2' import render_member with context %}


{% macro render_constant(builtin, c) %}
{%   if c.type.is_scalar %}
{{ c.name }} = {{ c.value }}
{%   else %}
@property
def {{ c.name }}(self):
    cdef gd_variant_t gdvariant
    # TODO: cache the constant on first fetch ?
    cdef gd_string_name_t gdname = gd_string_name_from_utf8("{{ c.original_name }}")
    pythonscript_gdextension.variant_get_constant_value({{ builtin.variant_type_name }}, &gdname, &gdvariant)
    gd_string_name_del(&gdname)
    return gd_variant_steal_into_pyobj(&gdvariant)
    # No need to destroy gdvariant given the conversion has stolen ownership on data !
{%   endif %}
{% endmacro %}


{% macro render_class(builtin) %}
@cython.freelist(8)
@cython.final
cdef class {{ builtin.cy_type }}:
    # Constructors
    {{ render_constructors(builtin) | indent }}

{% if not builtin.is_stack_only %}
    # Destructor
    def __dealloc__({{ builtin.cy_type }} self):
        # /!\ if `__cinit__` is skipped, `_gd_data` must be initialized by
        # hand otherwise we will get a segfault here
        {{ builtin.c_name_prefix }}_del(&self._gd_data)
{% endif %}

    def __repr__(self):
{%   if builtin.is_transparent_builtin %}
        return f"{{ builtin.cy_type }}({% for member in builtin.c_struct_members %}{{ member.name }}={self.{{ member.name }}}{% if not loop.last %}, {% endif %}{% endfor %})"
{%   elif builtin.original_name == "String" %}
        return f"{{ builtin.cy_type}}({self.to_pystr()!r})"
{%   else %}
        # TODO: I'm still not sure if this call steals self._gd_data or copies it...
        cdef gd_variant_t gdvar = {{ builtin.c_name_prefix }}_into_variant(&self._gd_data)
        cdef gd_string_t gdstr
        pythonscript_gdextension.variant_stringify(&gdvar, &gdstr)
        try:
            return gd_string_to_pystr(&gdstr)
        finally:
            gd_variant_del(&gdvar)
            gd_string_del(&gdstr)
{%   endif %}
{% if builtin.original_name == "String" %}
    def __str__(self):
        return self.to_pystr()
{% elif builtin.original_name in ("Array", "Dictionary") or builtin.is_packed_array %}
    def __len__(self):
        return self.size()

{% endif %}
{% if builtin.constants %}
    # Constants

{% endif %}
{% for c in builtin.constants %}
    {{ render_constant(builtin, c) | indent }}
{% endfor %}

{% if builtin.members %}
    # Members

{% endif %}
{% for m in builtin.members %}
    {{ render_member(builtin, m) | indent }}
{% endfor %}
{% if builtin.indexing_return_type and not builtin.is_keyed%}
    # TODO: handle out of range error ?

    def __getitem__(self, GDExtensionInt index):
        return self._getitem(index)

    def __setitem__(self, GDExtensionInt index, value):
        self._setitem(index, value)
{% elif builtin.indexing_return_type and builtin.is_keyed%}
    # TODO: handle out of range error ?

    def __getitem__(self, index):
        return self._getitem(index)

    def __setitem__(self, index, value):
        self._setitem(index, value)
{% endif %}
{% endmacro %}
