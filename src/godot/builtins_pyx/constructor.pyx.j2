{% macro render_default_constructor(builtin) -%}
{% if builtin.is_transparent_builtin %}

def __cinit__(self,
{%- for m in builtin.c_struct_members -%}
{{ m.type.cy_type }} {{ m.name }}{{ "" if m.type.is_scalar else " not None" }}={{ "0" if m.type.is_scalar else "{}()".format(m.type.cy_type) }},
{%- endfor -%}
):
{%   for m in builtin.c_struct_members %}
    self._gd_data.{{ m.name }} = {{ m.name }}{{ "" if m.type.is_scalar else "._gd_data" }}
{%   endfor %}

{% else %}

{# Opaque builtin, initialize with default empty constructor #}
def __cinit__(self):
    self._gd_data = {{ builtin.c_name_prefix }}_new()

{% endif %}
{%- endmacro %}


{% macro render_constructors(builtin) -%}

{# Custom constructors first #}
{% if builtin.original_name == "String" %}

def __cinit__(self, s=None):
    cdef GDExtensionTypePtr[1] args
    if s is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
    elif isinstance(s, str):
        self._gd_data = gd_string_from_unchecked_pystr(s)
    else:
        try:
{%   set constructor = builtin.get_constructor_from("String") %}
            self._gd_data = {{ constructor.c_name }}(&(<GDString?>s)._gd_data)
        except TypeError:
            try:
{%   set constructor = builtin.get_constructor_from("StringName") %}
                self._gd_data = {{ constructor.c_name }}(&(<StringName?>s)._gd_data)
            except TypeError:
{%   set constructor = builtin.get_constructor_from("NodePath") %}
                self._gd_data = {{ constructor.c_name }}(&(<NodePath?>s)._gd_data)

{% elif builtin.original_name == "StringName" %}

def __cinit__(self, s=None):
    cdef GDExtensionTypePtr[1] args
    cdef gd_string_t gds
    if s is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
    elif isinstance(s, str):
        self._gd_data = gd_string_name_from_unchecked_pystr(s)
    else:
        try:
{%   set constructor = builtin.get_constructor_from("String") %}
            self._gd_data = {{ constructor.c_name }}(&(<GDString?>s)._gd_data)
        except TypeError:
{%   set constructor = builtin.get_constructor_from("StringName") %}
            self._gd_data = {{ constructor.c_name }}(&(<StringName?>s)._gd_data)

{% elif builtin.original_name == "NodePath" %}

def __cinit__(self, s=None):
    cdef GDExtensionTypePtr[1] args
    cdef gd_string_t gds
    if s is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
    elif isinstance(s, str):
        gds = gd_string_from_unchecked_pystr(s)
        try:
{%   set constructor = builtin.get_constructor_from("String") %}
            self._gd_data = {{ constructor.c_name }}(&gds)
            return
        finally:
            gd_string_del(&gds)
    else:
        try:
{%   set constructor = builtin.get_constructor_from("String") %}
            self._gd_data = {{ constructor.c_name }}(&(<GDString?>s)._gd_data)
        except TypeError:
{%   set constructor = builtin.get_constructor_from("NodePath") %}
            self._gd_data = {{ constructor.c_name }}(&(<NodePath?>s)._gd_data)

{% elif builtin.original_name == "Dictionary" %}

def __cinit__(self, mapping=None):
    if mapping is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
        return
    try:
{%   set constructor = builtin.get_constructor_from("Dictionary") %}
        self._gd_data = {{ constructor.c_name }}(&(<GDDictionary?>mapping)._gd_data)
        return
    except TypeError:
        pass
    # Last chance, note we must initialize `self._gd_data` even if we are
    # going to raise a `TypeError`, otherwise destructor will segfault
    self._gd_data = {{ builtin.c_name_prefix }}_new()
    try:
        if isinstance(mapping, Mapping):
            for k, v in mapping.items():
                self._setattr(k, v)
        else:
            for k, v in mapping:
                self._setattr(k, v)
    except (TypeError, ValueError) as exc:
        raise TypeError("Expected Dictionary, collections.abc.Mapping or Sequence[Tuple[IntoGDAny, IntoGDAny]]")

{% elif builtin.original_name == "Array" %}

def __cinit__(self, iterable=None):
    if iterable is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
        return
{%   for packedtype in api.packed_array_types %}
{%     set constructor = builtin.get_constructor_from(packedtype.original_name) %}
    try:
        self._gd_data = {{ constructor.c_name }}(&(<{{ packedtype.cy_type }}?>iterable)._gd_data)
        return
    except TypeError:
        pass
{%   endfor %}
    try:
        {% set constructor = builtin.get_constructor_from("Array") %}
        self._gd_data = {{ constructor.c_name }}(&(<GDArray?>iterable)._gd_data)
    except TypeError:
        pass
    # Last chance, note we must initialize `self._gd_data` even if we are
    # going to raise a `TypeError`, otherwise destructor will segfault
    self._gd_data = {{ builtin.c_name_prefix }}_new()
    if isinstance(iterable, Iterable):
        {{ builtin.c_name_prefix }}_resize(&self._gd_data, len(iterable))
        for x in iterable:
            self.append(x)
    else:
        raise TypeError("Expected Array, Packed*Array or collections.abc.Iterable[IntoGDAny]")

{% elif builtin.is_packed_array %}

def __cinit__(self, iterable=None):
    if iterable is None:
        self._gd_data = {{ builtin.c_name_prefix }}_new()
        return
{%   set constructor = builtin.get_constructor_from(builtin.original_name) %}
    try:
        self._gd_data = {{ constructor.c_name }}(&(<{{ builtin.cy_type }}?>iterable)._gd_data)
    except TypeError:
        try:
            {% set constructor = builtin.get_constructor_from("Array") %}
            self._gd_data = {{ constructor.c_name }}(&(<GDArray?>iterable)._gd_data)
        except TypeError:
            # Last chance, note we must initialize `self._gd_data` even if we are
            # going to raise a `TypeError`, otherwise destructor will segfault
            self._gd_data = {{ builtin.c_name_prefix }}_new()
            if isinstance(iterable, Iterable):
                {{ builtin.c_name_prefix }}_resize(&self._gd_data, len(iterable))
                for x in iterable:
                    self.append(x)
            else:
                raise TypeError("Expected Array, {{ builtin.cy_type }} or collections.abc.Iterable[{{ builtin.packed_array_item_type.cy_type }}]")

{% else %}
{# Default constructor #}
{{ render_default_constructor(builtin) }}
{% endif %}

{% endmacro %}
